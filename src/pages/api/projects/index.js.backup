// src/pages/api/projects/index.js - ä¸ç®€åŒ– Prisma å…¼å®¹çš„ç‰ˆæœ¬
import { getServerSession } from "next-auth/next";
import { authOptions } from "../../../lib/auth";
import prisma from '../../../lib/prisma'; // ğŸ”§ ç›´æ¥ä½¿ç”¨ç®€åŒ–ç‰ˆæœ¬çš„ prisma

// ğŸ”§ é…ç½®å¸¸é‡
const CONFIG = {
  ALLOWED_METHODS: ['GET', 'POST', 'OPTIONS'],
  MAX_PROJECTS_PER_PAGE: 100,
  DEFAULT_PAGE_SIZE: 20,
  VALID_PROJECT_TYPES: ['DRAFT_PROJECT', 'STANDARD_PROJECT', 'TEAM_PROJECT', 'GENERAL'],
  VALID_PROJECT_STATUSES: ['DRAFT', 'PUBLISHED', 'RECRUITING', 'IN_PROGRESS', 'COMPLETED', 'ARCHIVED'],
  VALID_SORT_FIELDS: ['createdAt', 'updatedAt', 'title'],
  CACHE_CONTROL: 'private, no-cache, no-store, must-revalidate'
};

// ğŸ”§ å·¥å…·å‡½æ•°ï¼šè®¾ç½®å“åº”å¤´
function setResponseHeaders(res) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', CONFIG.ALLOWED_METHODS.join(', '));
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-Requested-With');
  res.setHeader('Cache-Control', CONFIG.CACHE_CONTROL);
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
}

// ğŸ”§ å·¥å…·å‡½æ•°ï¼šéªŒè¯ç”¨æˆ·ä¼šè¯
async function validateSession(req, res) {
  try {
    const session = await getServerSession(req, res, authOptions);
    
    console.log('ğŸ” ä¼šè¯éªŒè¯è¯¦æƒ…:', {
      hasSession: !!session,
      hasUser: !!session?.user,
      userId: session?.user?.id,
      userEmail: session?.user?.email
    });

    if (!session?.user?.id) {
      console.warn('ğŸš« æœªæˆæƒè®¿é—®: ç¼ºå°‘æœ‰æ•ˆçš„ç”¨æˆ·ä¼šè¯');
      return { valid: false, error: 'æœªç»æˆæƒçš„è®¿é—®', code: 'UNAUTHORIZED' };
    }

    // ğŸ”§ ç®€åŒ–ç”¨æˆ·IDå¤„ç†
    let userId;
    const rawUserId = session.user.id;
    
    if (typeof rawUserId === 'number') {
      userId = rawUserId;
    } else if (typeof rawUserId === 'string') {
      // ç®€å•è§£æç”¨æˆ·ID
      const idNum = parseInt(rawUserId);
      userId = isNaN(idNum) ? 1 : idNum;
    } else {
      userId = 1; // é»˜è®¤å›é€€
    }

    if (userId <= 0) {
      console.error('âŒ æ— æ•ˆçš„ç”¨æˆ·ID:', session.user.id, 'è§£æå:', userId);
      return { valid: false, error: 'æ— æ•ˆçš„ç”¨æˆ·ID', code: 'INVALID_USER_ID' };
    }

    return { 
      valid: true, 
      userId, 
      session
    };
  } catch (error) {
    console.error('âŒ ä¼šè¯éªŒè¯å¤±è´¥:', error);
    return { 
      valid: false, 
      error: 'ä¼šè¯éªŒè¯å¤±è´¥', 
      code: 'SESSION_VALIDATION_FAILED'
    };
  }
}

// ğŸ”§ å·¥å…·å‡½æ•°ï¼šéªŒè¯æŸ¥è¯¢å‚æ•°
function validateQueryParams(query) {
  const { 
    type, 
    status, 
    search,
    page = 1, 
    limit = CONFIG.DEFAULT_PAGE_SIZE,
    sortBy = 'updatedAt',
    sortOrder = 'desc'
  } = query;

  // éªŒè¯åˆ†é¡µå‚æ•°
  const pageNum = Math.max(1, parseInt(page) || 1);
  const limitNum = Math.min(
    Math.max(1, parseInt(limit) || CONFIG.DEFAULT_PAGE_SIZE), 
    CONFIG.MAX_PROJECTS_PER_PAGE
  );

  // éªŒè¯æ’åºå‚æ•°
  const sortField = CONFIG.VALID_SORT_FIELDS.includes(sortBy) ? sortBy : 'updatedAt';
  const sortDir = sortOrder === 'asc' ? 'asc' : 'desc';

  // éªŒè¯è¿‡æ»¤å‚æ•°
  const validatedType = type && CONFIG.VALID_PROJECT_TYPES.includes(type) ? type : undefined;
  const validatedStatus = status && CONFIG.VALID_PROJECT_STATUSES.includes(status) ? status : undefined;
  const validatedSearch = search && typeof search === 'string' && search.trim().length > 0 ? search.trim() : undefined;

  return {
    page: pageNum,
    limit: limitNum,
    skip: (pageNum - 1) * limitNum,
    sortBy: sortField,
    sortOrder: sortDir,
    type: validatedType,
    status: validatedStatus,
    search: validatedSearch
  };
}

// ğŸ”§ ç®€åŒ–çš„é”™è¯¯å¤„ç†
function handleApiError(error, requestId, res) {
  console.error(`âŒ [${requestId}] APIé”™è¯¯:`, error.message);

  // å¤„ç† Prisma é”™è¯¯
  if (error.code?.startsWith('P')) {
    switch (error.code) {
      case 'P2025':
        return res.status(404).json({ 
          success: false,
          error: 'è®°å½•æœªæ‰¾åˆ°',
          requestId
        });
      case 'P1017':
      case 'P1001':
        return res.status(503).json({ 
          success: false,
          error: 'æ•°æ®åº“è¿æ¥å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•',
          requestId
        });
      case 'P2002':
        return res.status(409).json({ 
          success: false,
          error: 'è®°å½•å·²å­˜åœ¨',
          requestId
        });
      default:
        return res.status(500).json({ 
          success: false,
          error: 'æ•°æ®åº“æ“ä½œå¤±è´¥',
          requestId,
          ...(process.env.NODE_ENV === 'development' && { code: error.code })
        });
    }
  }

  // é€šç”¨é”™è¯¯å¤„ç†
  return res.status(500).json({ 
    success: false,
    error: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
    requestId,
    ...(process.env.NODE_ENV === 'development' && { details: error.message })
  });
}

export default async function handler(req, res) {
  const requestId = Math.random().toString(36).substr(2, 9);
  
  console.log(`ğŸ” [${requestId}] é¡¹ç›®APIè¯·æ±‚:`, { 
    method: req.method, 
    url: req.url,
    query: req.query
  });

  // è®¾ç½®å“åº”å¤´
  setResponseHeaders(res);

  if (req.method === 'OPTIONS') {
    console.log(`âœ… [${requestId}] OPTIONS è¯·æ±‚å¤„ç†å®Œæˆ`);
    return res.status(200).end();
  }

  try {
    // éªŒè¯ä¼šè¯
    const sessionValidation = await validateSession(req, res);
    if (!sessionValidation.valid) {
      console.warn(`ğŸš« [${requestId}] ä¼šè¯éªŒè¯å¤±è´¥:`, sessionValidation.error);
      return res.status(401).json({ 
        success: false,
        error: sessionValidation.error,
        code: sessionValidation.code,
        requestId
      });
    }

    const { userId } = sessionValidation;

    console.log(`ğŸ“‚ [${requestId}] é¡¹ç›®APIå¤„ç†:`, { 
      method: req.method, 
      userId,
      path: req.url 
    });

    // è·¯ç”±åˆ°å¯¹åº”çš„å¤„ç†æ–¹æ³•
    if (req.method === 'GET') {
      return await handleGetProjects(req, res, userId, requestId);
    }

    if (req.method === 'POST') {
      return await handleCreateProject(req, res, userId, requestId);
    }

    console.warn(`âŒ [${requestId}] ä¸æ”¯æŒçš„æ–¹æ³•: ${req.method}`);
    return res.status(405).json({ 
      success: false,
      error: 'æ–¹æ³•ä¸å…è®¸',
      allowed: CONFIG.ALLOWED_METHODS,
      requestId
    });

  } catch (error) {
    return handleApiError(error, requestId, res);
  }
}

// ğŸ”§ ç®€åŒ–çš„è·å–é¡¹ç›®åˆ—è¡¨
async function handleGetProjects(req, res, userId, requestId) {
  try {
    // éªŒè¯æŸ¥è¯¢å‚æ•°
    const {
      page,
      limit,
      skip,
      sortBy,
      sortOrder,
      type,
      status,
      search
    } = validateQueryParams(req.query);

    console.log(`ğŸ” [${requestId}] æŸ¥è¯¢å‚æ•°:`, { 
      userId, 
      page, 
      limit,
      sortBy,
      sortOrder
    });

    // æ„å»ºæŸ¥è¯¢æ¡ä»¶
    const where = {
      OR: [
        { ownerId: userId },
        { projectMembers: { some: { userId: userId } } }
      ]
    };

    // æ·»åŠ è¿‡æ»¤æ¡ä»¶
    if (type) where.type = type;
    if (status) where.status = status;
    if (search) {
      where.OR = [
        ...where.OR,
        { 
          title: { 
            contains: search, 
            mode: 'insensitive' 
          } 
        },
        { 
          description: { 
            contains: search, 
            mode: 'insensitive' 
          } 
        }
      ];
    }

    console.log(`ğŸ“Š [${requestId}] æ‰§è¡Œæ•°æ®åº“æŸ¥è¯¢...`);

    // è·å–é¡¹ç›®åˆ—è¡¨å’Œæ€»æ•°
    const [projects, total] = await Promise.all([
      prisma.project.findMany({
        where,
        include: {
          owner: {
            select: { 
              id: true, 
              name: true, 
              email: true
            }
          },
          projectMembers: {
            include: {
              user: {
                select: { 
                  id: true, 
                  name: true, 
                  email: true
                }
              }
            }
          },
          _count: {
            select: {
              projectMembers: true,
              projectFiles: true,
              projectTasks: true
            }
          }
        },
        orderBy: { 
          [sortBy]: sortOrder 
        },
        skip,
        take: limit
      }),
      prisma.project.count({ where })
    ]);

    // æ ¼å¼åŒ–å“åº”æ•°æ®
    const formattedProjects = projects.map(project => ({
      id: project.id,
      title: project.title || 'æœªå‘½åé¡¹ç›®',
      description: project.description || '',
      type: project.type || 'GENERAL',
      status: project.status || 'DRAFT',
      ownerId: project.ownerId,
      owner: project.owner,
      createdAt: project.createdAt.toISOString(),
      updatedAt: project.updatedAt.toISOString(),
      isOwner: project.ownerId === userId,
      memberCount: project._count.projectMembers,
      fileCount: project._count.projectFiles,
      taskCount: project._count.projectTasks,
      members: project.projectMembers?.map(member => ({
        id: member.user.id,
        name: member.user.name,
        email: member.user.email,
        role: member.role
      })) || []
    }));

    console.log(`âœ… [${requestId}] è·å–é¡¹ç›®æˆåŠŸ: ${formattedProjects.length} ä¸ªé¡¹ç›®`);

    return res.status(200).json({
      success: true,
      data: {
        projects: formattedProjects,
        pagination: {
          page,
          limit,
          total,
          pages: Math.ceil(total / limit),
          hasNext: page * limit < total,
          hasPrev: page > 1
        },
        filters: {
          type: type || 'all',
          status: status || 'all',
          search: search || ''
        },
        summary: {
          totalProjects: total,
          visibleProjects: formattedProjects.length,
          ownedProjects: projects.filter(p => p.ownerId === userId).length
        }
      },
      requestId,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error(`âŒ [${requestId}] è·å–é¡¹ç›®åˆ—è¡¨å¤±è´¥:`, error);
    return handleApiError(error, requestId, res);
  }
}

// ğŸ”§ ç®€åŒ–çš„åˆ›å»ºé¡¹ç›®
async function handleCreateProject(req, res, userId, requestId) {
  try {
    // è§£æè¯·æ±‚ä½“
    let projectData;
    try {
      projectData = typeof req.body === 'string' ? JSON.parse(req.body) : req.body;
    } catch (parseError) {
      return res.status(400).json({
        success: false,
        error: 'æ— æ•ˆçš„ JSON æ•°æ®',
        requestId
      });
    }

    const { title, description, type = 'GENERAL', status = 'DRAFT' } = projectData;

    // éªŒè¯å¿…éœ€å­—æ®µ
    if (!title || typeof title !== 'string' || title.trim().length === 0) {
      return res.status(400).json({
        success: false,
        error: 'é¡¹ç›®æ ‡é¢˜ä¸èƒ½ä¸ºç©º',
        requestId
      });
    }

    // éªŒè¯æ ‡é¢˜é•¿åº¦
    if (title.trim().length > 200) {
      return res.status(400).json({
        success: false,
        error: 'é¡¹ç›®æ ‡é¢˜ä¸èƒ½è¶…è¿‡200ä¸ªå­—ç¬¦',
        requestId
      });
    }

    // éªŒè¯ç±»å‹å’ŒçŠ¶æ€
    if (!CONFIG.VALID_PROJECT_TYPES.includes(type)) {
      return res.status(400).json({
        success: false,
        error: 'æ— æ•ˆçš„é¡¹ç›®ç±»å‹',
        requestId
      });
    }

    if (!CONFIG.VALID_PROJECT_STATUSES.includes(status)) {
      return res.status(400).json({
        success: false,
        error: 'æ— æ•ˆçš„é¡¹ç›®çŠ¶æ€',
        requestId
      });
    }

    console.log(`ğŸ†• [${requestId}] åˆ›å»ºæ–°é¡¹ç›®:`, {
      userId,
      title: title.substring(0, 50),
      type,
      status
    });

    // åˆ›å»ºé¡¹ç›®
    const project = await prisma.project.create({
      data: {
        title: title.trim(),
        description: description?.trim() || '',
        type,
        status,
        visibility: 'PRIVATE',
        ownerId: userId,
        content: ''
      },
      include: {
        owner: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        _count: {
          select: {
            projectMembers: true,
            projectFiles: true,
            projectTasks: true
          }
        }
      }
    });

    // è‡ªåŠ¨å°†åˆ›å»ºè€…æ·»åŠ ä¸ºé¡¹ç›®æˆå‘˜
    await prisma.projectMember.create({
      data: {
        projectId: project.id,
        userId: userId,
        role: 'OWNER'
      }
    });

    console.log(`âœ… [${requestId}] é¡¹ç›®åˆ›å»ºæˆåŠŸ:`, { projectId: project.id });

    // æ ¼å¼åŒ–å“åº”æ•°æ®
    const formattedProject = {
      id: project.id,
      title: project.title,
      description: project.description,
      type: project.type,
      status: project.status,
      ownerId: project.ownerId,
      owner: project.owner,
      createdAt: project.createdAt.toISOString(),
      updatedAt: project.updatedAt.toISOString(),
      isOwner: true,
      memberCount: project._count.projectMembers,
      fileCount: project._count.projectFiles,
      taskCount: project._count.projectTasks,
      members: [{
        id: project.owner.id,
        name: project.owner.name,
        email: project.owner.email,
        role: 'OWNER'
      }]
    };

    return res.status(201).json({
      success: true,
      data: formattedProject,
      message: 'é¡¹ç›®åˆ›å»ºæˆåŠŸ',
      requestId,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error(`âŒ [${requestId}] åˆ›å»ºé¡¹ç›®å¤±è´¥:`, error);
    return handleApiError(error, requestId, res);
  }
}

// ğŸ”§ API é…ç½®
export const config = {
  api: {
    bodyParser: {
      sizeLimit: '10mb',
    },
    responseLimit: '10mb',
  },
};